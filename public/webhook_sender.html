<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Discord Webhook Sender</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 40px; min-height: 100vh; background: #000 !important; color: #eee; }
    #particlesCanvas { pointer-events: none; }
    label { display: block; margin-top: 20px; }
    input, textarea {
      width: 100%;
      padding: 8px;
      margin-top: 5px;
      border: 1px solid #ccc;
      border-radius: 4px;
      transition: box-shadow 0.3s, border-color 0.3s;
  background: rgba(30, 30, 30, 0.7);
      color: #eee;
    }
    input:focus, textarea:focus { box-shadow: 0 0 8px #4caf50; border-color: #4caf50; }
    button { margin-top: 20px; padding: 10px 20px; border-radius: 6px; border: none; background: #4caf50; color: #fff; cursor: pointer; transition: background 0.3s, transform 0.1s; }
    button:hover { background: #388e3c; transform: scale(1.05); }
    button:active { background: #2e7031; transform: scale(0.98); }
    .status { margin-top: 20px; opacity: 0; transition: opacity 2s; }
    .status.show { opacity: 1; }
    #history > div { opacity: 0; transition: opacity 2s; }
    #history > div.show { opacity: 1; }
    #history { scroll-behavior: smooth; }
    .dark-mode { background: #000 !important; color: #eee; }
    .dark-mode input, .dark-mode textarea {
      background: rgba(30, 30, 30, 0.7) !important;
      color: #eee;
    }
    .dark-mode button { background: #222; color: #eee; border: 1px solid #444; }
    .dark-mode #progressBarContainer {
      background: rgba(30, 30, 30, 0.7) !important;
    }
    .dark-mode #progressBar {
      height: 100%;
      width: 0;
      background: #4caf50 !important;
      transition: width 0.3s;
    }
    
    body.gradient-bg {
      background: linear-gradient(-45deg, #ee7752, #e73c7e, #23a6d5, #23d5ab);
      background-size: 400% 400%;
      animation: gradientBG 15s ease infinite;
    }
    @keyframes gradientBG {
      0% {background-position: 0% 50%;}
      50% {background-position: 100% 50%;}
      100% {background-position: 0% 50%;}
    }
    .log-success { color: green; }
    .log-fail { color: red; }
    .log-rate { color: orange; }
    #deleteWebhookBtn {
      background: #d32f2f;
      color: #fff;
      border: none;
      border-radius: 6px;
      box-shadow: 0 0 10px 2px rgba(211,47,47,0.5);
      margin-top: 20px;
      padding: 10px 20px;
      cursor: pointer;
      transition: background 0.3s, box-shadow 0.3s, transform 0.15s;
    }
    #deleteWebhookBtn:hover {
      background: #b71c1c;
      box-shadow: 0 0 18px 4px rgba(211,47,47,0.7);
      transform: scale(1.05);
    }
    #deleteWebhookBtn:active {
      background: #c62828;
      box-shadow: 0 0 30px 8px rgba(211,47,47,0.8);
      transform: scale(0.95) rotate(-2deg);
    }
    #checkWebhookBtn {
      background: #1a237e;
      color: #fff;
      border: none;
      border-radius: 6px;
      box-shadow: 0 0 10px 2px rgba(26,35,126,0.5);
      margin-top: 20px;
      padding: 10px 20px;
      cursor: pointer;
      transition: background 0.3s, box-shadow 0.3s, transform 0.15s;
    }
    #checkWebhookBtn:hover {
      background: #283593;
      box-shadow: 0 0 18px 4px rgba(26,35,126,0.7);
      transform: scale(1.05);
    }
    #checkWebhookBtn:active {
      background: #3949ab;
      box-shadow: 0 0 30px 8px rgba(26,35,126,0.8);
      transform: scale(0.95) rotate(-2deg);
    }
  </style>
</head>
<body>
  <h1>Discord Webhook Sender</h1>
  
document.getElementById('logoutBtn').addEventListener('click', async function() {
  try {
    await fetch('http://localhost:3000/logout', {
      method: 'POST',
      credentials: 'include'
    });
  } catch (error) {
    
  }
  window.location.href = '/login.html';
});
  <form id="webhookForm">
    <label for="urls">Webhook URLs (comma separated):</label>
    <input type="text" id="urls" name="urls" required>

    <label for="username">Username (optional):</label>
    <input type="text" id="username" name="username">

    <label for="avatar">Avatar URL (optional):</label>
    <input type="text" id="avatar" name="avatar">

    <label for="message">Message:</label>
    <textarea id="message" name="message" rows="4" required></textarea>

    <label for="count">Number of Messages (per batch):</label>
    <input type="number" id="count" name="count" min="1" value="5" required>

    <label for="maxBatches">Max Batches (0 = infinite):</label>
    <input type="number" id="maxBatches" name="maxBatches" min="0" value="0" required>

    <button type="button" id="startBtn">Start</button>
    <button type="button" id="stopBtn">Stop</button>
    <button type="button" id="darkModeBtn">Toggle Dark Mode</button>
    <button type="button" id="saveBtn">Save Message</button>
    <button type="button" id="loadBtn">Load Message</button>
    <button type="button" id="deleteWebhookBtn">Delete Webhook</button>
    <button type="button" id="checkWebhookBtn">Check Webhook Status</button>
  </form>
  <div class="status" id="status"></div>
  <div id="progressBarContainer" style="width:100%;height:30px;background:rgba(30, 30, 30, 0.7);border-radius:8px;overflow:hidden;margin-top:20px;">
    <div id="progressBar" style="height:100%;width:0;background:#eee;transition:width 0.3s;"></div>
  </div>
  <div id="history" style="margin-top:30px; max-height:200px; overflow-y:auto;"></div>
  <canvas id="particlesCanvas" style="position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:-1;"></canvas>

  <script>

fetch('http://localhost:3000/auth-status', { credentials: 'include' })
  .then(res => res.json())
  .then(data => {
    if (!data.authenticated) {
      window.location.href = 'login.html';
    }
  });

    let running = false;
    let timeoutId = null;
    let batchCount = 0;
    let maxBatches = 0;
    const historyDiv = document.getElementById('history');

    
    document.body.classList.remove('gradient-bg');
    document.body.classList.add('dark-mode');
    
    const canvas = document.getElementById('particlesCanvas');
    const ctx = canvas.getContext('2d');
    let particles = [];
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();
    function createParticle() {
      return {
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
  r: (Math.random() * 4 + 2) * 6,
        dx: (Math.random() - 0.5) * 0.7,
        dy: (Math.random() - 0.5) * 0.7,
        glow: 'rgba(255,255,255,0.5)'
      };
    }
    for (let i = 0; i < 40; i++) particles.push(createParticle());
   
    const particleImg = new Image();
    particleImg.src = 'https://i.imgur.com/3C95ejn.jpg';
    function drawParticles() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (const p of particles) {
        ctx.save();
        ctx.shadowColor = 'rgba(255,255,255,0.7)';
        ctx.shadowBlur = 12;
        if (particleImg.complete) {
          ctx.globalAlpha = 0.85;
          ctx.drawImage(particleImg, p.x - p.r, p.y - p.r, p.r * 2, p.r * 2);
        } else {
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
          ctx.fillStyle = 'white';
          ctx.fill();
        }
        ctx.restore();
        p.x += p.dx;
        p.y += p.dy;
        if (p.x < 0 || p.x > canvas.width) p.dx *= -1;
        if (p.y < 0 || p.y > canvas.height) p.dy *= -1;
      }
      requestAnimationFrame(drawParticles);
    }
    drawParticles();

    
    function showStatus(msg) {
      const statusDiv = document.getElementById('status');
      statusDiv.textContent = msg;
      statusDiv.classList.add('show');
      setTimeout(() => statusDiv.classList.remove('show'), 2000);
    }

    
    function addLog(msg, type = '') {
      const entry = document.createElement('div');
      entry.className = type;
      entry.textContent = msg;
      historyDiv.appendChild(entry);
      setTimeout(() => entry.classList.add('show'), 10);
      historyDiv.scrollTop = historyDiv.scrollHeight;
    }

    async function sendMessages(urls, message, count, username, avatar, statusDiv) {
      let success = 0, fail = 0;
      const total = count * urls.length;
      let sent = 0;
      const progressBar = document.getElementById('progressBar');
      progressBar.style.width = '0';
      for (let i = 1; i <= count; i++) {
        for (const url of urls) {
          const payload = { content: message + (count > 1 ? `` : '') };
          if (username) payload.username = username;
          if (avatar) payload.avatar_url = avatar;
          try {
            const res = await fetch(url, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload)
            });
            sent++;
            progressBar.style.width = ((sent / total) * 100) + '%';
            if (res.ok) {
              success++;
              addLog(`Success: Sent to ${url} - Message #${i}`, 'log-success');
            } else {
              fail++;
              let rateInfo = '';
              try {
                const data = await res.json();
                if (data.retry_after) {
                  rateInfo = ` (Rate limited, retry after ${data.retry_after}ms)`;
                  addLog(`Rate Limit: ${rateInfo}`, 'log-rate');
                }
                addLog(`Fail: ${url} - Message #${i} - ${JSON.stringify(data)}`, 'log-fail');
              } catch (err) {
                addLog(`Fail: ${url} - Message #${i} - HTTP ${res.status}`, 'log-fail');
              }
            }
          } catch (err) {
            fail++;
            addLog(`Error: ${url} - Message #${i} - ${err}`, 'log-fail');
          }
        }
      }
      setTimeout(() => { progressBar.style.width = '0'; }, 800);
      showStatus(`Batch Done! Success: ${success}, Failed: ${fail}`);
    }

    function getRandomDelay() {
      return Math.floor(Math.random() * (7000 - 3000 + 1)) + 3000;
    }

    function loopSend() {
      if (!running) return;
      if (maxBatches > 0 && batchCount >= maxBatches) {
        running = false;
        showStatus(`Stopped after ${batchCount} batches.`);
        return;
      }
      batchCount++;
      const urls = document.getElementById('urls').value.split(',').map(u => u.trim()).filter(u => u);
      const message = document.getElementById('message').value;
      const count = parseInt(document.getElementById('count').value);
      const username = document.getElementById('username').value;
      const avatar = document.getElementById('avatar').value;
      const statusDiv = document.getElementById('status');
      sendMessages(urls, message, count, username, avatar, statusDiv);
      timeoutId = setTimeout(loopSend, getRandomDelay());
    }

    document.getElementById('startBtn').addEventListener('click', function() {
      if (running) return;
      running = true;
      batchCount = 0;
      maxBatches = parseInt(document.getElementById('maxBatches').value);
      showStatus('Started sending...');
      loopSend();
    });

    document.getElementById('stopBtn').addEventListener('click', function() {
      running = false;
      clearTimeout(timeoutId);
      showStatus('Stopped.');
    });

    document.getElementById('darkModeBtn').addEventListener('click', function() {
      document.body.classList.toggle('dark-mode');
    });

    document.getElementById('saveBtn').addEventListener('click', function() {
      const message = document.getElementById('message').value;
      localStorage.setItem('savedMessage', message);
      showStatus('Message saved!');
    });

    document.getElementById('loadBtn').addEventListener('click', function() {
      const saved = localStorage.getItem('savedMessage');
      if (saved !== null) {
        document.getElementById('message').value = saved;
        showStatus('Message loaded!');
      } else {
        showStatus('No saved message found.');
      }
    });

    document.getElementById('deleteWebhookBtn').addEventListener('click', async function() {
      const urls = document.getElementById('urls').value.split(',').map(u => u.trim()).filter(u => u);
      if (urls.length === 0) {
        showStatus('No webhook URL provided.');
        return;
      }
      let deleted = 0, failed = 0;
      for (const url of urls) {
        try {
          const res = await fetch(url, { method: 'DELETE' });
          if (res.ok) {
            addLog(`Webhook deleted: ${url}`, 'log-success');
            deleted++;
          } else {
            addLog(`Failed to delete webhook: ${url} (HTTP ${res.status})`, 'log-fail');
            failed++;
          }
        } catch (err) {
          addLog(`Error deleting webhook: ${url} - ${err}`, 'log-fail');
          failed++;
        }
      }
      showStatus(`Delete complete. Success: ${deleted}, Failed: ${failed}`);
    });

    document.getElementById('checkWebhookBtn').addEventListener('click', async function() {
      const urls = document.getElementById('urls').value.split(',').map(u => u.trim()).filter(u => u);
      if (urls.length === 0) {
        showStatus('No webhook URL provided.');
        return;
      }
      for (const url of urls) {
        try {
          const res = await fetch(url);
          if (res.ok) {
            const data = await res.json();
            addLog(`Webhook valid: ${url} (Name: ${data.name || 'N/A'}, Channel: ${data.channel_id || 'N/A'})`, 'log-success');
          } else {
            addLog(`Webhook invalid: ${url} (HTTP ${res.status})`, 'log-fail');
          }
        } catch (err) {
          addLog(`Error checking webhook: ${url} - ${err}`, 'log-fail');
        }
      }
      showStatus('Webhook status check complete.');
    });

    const sendBtn = document.querySelector('form button[type="submit"]');
    if (sendBtn) sendBtn.style.display = 'none';
  </script>
</body>
</html>